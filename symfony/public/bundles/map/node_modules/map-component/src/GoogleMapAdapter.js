import MapAdapter from "./MapAdapter.js"

/**
 * @module GoogleMapAdapter
 * 
 * @desc
 * A map adapter allowing the map component to display a map powered by Google's API
 * 
 * Implements the MapComponent~AddapterAddon interface. 
 * As one of the default adapter of the MapComponent, there is no need to declare it in the add-ons.
 * 
 * Use it by setting the attribute poweredby to "google" on the map-component.
 * 
 * This adapter also check the following html attributes on the map-component at initializations:
 * 
 *  - **api-key** : This attibute is mandatory. It is used as key to load google api. 
 *  - **language** : Optional, if specified will load the api in this language.
 * 
 * Changing the value of those attribute once google map API have been loaded have no effect.
 * 
 * #### Example
 * ```html
 * <map-component poweredby="google" api-key="ASnlnzapdpazPJDDZ65" language="fr" ... ></map-component>
 * ``` 
 * @implements {MapComponent~AddapterAddon}
 */

/**
 * 
 * @override
 */
export function createAdapter (mapComponent,featureModules){
	return new GoogleAdapter(mapComponent)
}
/**
 * 
 * @override
 */
export async function createMap(adapter,mapComponent,featureModules){
	
	let key = mapComponent.getAttribute("api-key")
	if(!key)
		throw new Error("The component "+mapComponent.tagName+" should have an attribute api-key containing the google's API key in order to work with google map.")
	

	await loadAPI(mapComponent,key)


	let mapDiv = document.createElement("div")
	mapDiv.id = "mapContainer"

	mapComponent.shadowRoot.append(mapDiv)

	let map = initMap(mapComponent,mapDiv)

	// Need to wait the projection to be ready and usable.
	let projectionReady = new Promise(res => 
		google.maps.event.addListenerOnce(map, 'projection_changed', res)
	)

	await projectionReady

	_(adapter).map = map

	return map

	
}
/**
 * 
 * @override
 * @type {string}
 */
export const enabling = "google"


// ****************************************************************************
// *                                  Adapter                                 *
// ****************************************************************************

/**
 * An adapter class providing a facade for the most basic feature of the google map API.
 *
 * @class      GoogleAdapter
 * @implements {MapAdapter}
 */
class GoogleAdapter extends MapAdapter {

	constructor(mapComponent) {
		
		super()

		priv(this)
		_(this).eventHandles = new WeakMap()
		_(this).mapComponent = mapComponent
	}


	/**
	 * @override
	 */
	setCenter(latLngCenter,olds) {

		let latLng = toLatLng(latLngCenter)
		
		let toNan = isNaN(latLngCenter.latitude+latLngCenter.longitude)
		let fromNan = isNaN(olds.latitude+olds.longitude)

		// We cannot want to go to NaN.
		if(toNan)
			return
		
		// Panning from NaN take a really long time to Google map.
		if(isNaN(fromNan))
			_(this).map.setCenter(latLng)
		else
			_(this).map.panTo(latLng)
	}

	/**
	 * @override
	 */
	getCenter(){
		let c = _(this).map.getCenter()
		return {latitude : c.lat(), longitude : c.lng()}
	}

	/**
	 * @override
	 */
	setZoom(z) {
		_(this).notUserZoom = true
		_(this).map.setZoom(z)
		_(this).notUserZoom = false
	}

	/**
	 * @override
	 */
	getZoom(){
		return _(this).map.getZoom()
	}

	/**
	 * @override
	 */
	addMapEvent(eventStandardName,callback) {
		let eventGoogleName = eventTranslation[eventStandardName]
		if(eventStandardName === "map_user_zoom"){
			let baseCB = callback
			let that = this
			
			callback = function(evt){
				if(!_(that).notUserZoom)
					baseCB.call(this,evt)
			}
		}
		let handle = _(this).map.addListener(eventGoogleName,callback)
		_(this).eventHandles.set(callback,handle)
	}

	/**
	 * @override
	 */
	removeMapEvent(eventStandardName,callback) {
		let handle = _(this).eventHandles.get(callback)
		
		google.maps.event.removeListener(handle)
	}

	/**
	 * @override
	 */
	latLngToComponentPx(latLng,opt_centerref,opt_zoomref){

		let position = toLatLng(latLng)

		let zoom = arguments.length > 2 ? opt_zoomref : _(this).map.getZoom()
		var scale = 2 ** zoom;
		var proj = _(this).map.getProjection();
		var bounds = _(this).map.getBounds();

		var ref = proj.fromLatLngToPoint(
			arguments.length > 1 ?
			
				toLatLng(opt_centerref) :

				new google.maps.LatLng(
					bounds.getNorthEast().lat(),
					bounds.getSouthWest().lng()
				)
		)


		var point = proj.fromLatLngToPoint(position);

		let x = (point.x - ref.x) * scale
		let y = (point.y - ref.y) * scale

		if(arguments.length > 1 ){
			let box = _(this).mapComponent.getBox()
			x += box.width / 2
			y += box.height / 2
		}
		return new google.maps.Point(
			Math.floor(x),
			Math.floor(y)
		);
	}

	/**
	 * @override
	 */
	componentPxToLatLng(px){
		var scale = Math.pow(2, _(this).map.getZoom());
		var proj = _(this).map.getProjection();
		var bounds = _(this).map.getBounds();

		var nw = proj.fromLatLngToPoint(
		new google.maps.LatLng(
		  bounds.getNorthEast().lat(),
		  bounds.getSouthWest().lng()
		));
		var point = new google.maps.Point();

		point.x = px.x / scale + nw.x;
		point.y = px.y / scale + nw.y;

		let latLng =  proj.fromPointToLatLng(point);

		return {latitude : latLng.lat(),longitude:latLng.lng()}
	}

	/**
	 * @override
	 * 
	 * @type {external:google.maps.Map}
	 */
	get mapObject(){
		return _(this).map
	}
} 

// ****************************************************************************
// *                              Class Privates                              *
// ****************************************************************************
const  eventTranslation = {

	"map_drag" : "drag",
	"map_dragend" : "dragend",
	"map_dragstart" : "dragstart",
	"map_idle" : "idle",
	"map_zoom" : "zoom_changed",
	"map_user_zoom" : "zoom_changed"
}


// ****************************************************************************
// *                              Module Privates                             *
// ****************************************************************************


const apiUrlWithoutKey = "https://maps.googleapis.com/maps/api/js?key="

var loadAPI = async function(mapComponent,key){

	let lib = document.createElement("script")
	lib.setAttribute("type","text/javascript")
	lib.setAttribute("async","true")

	let callBackName = randomFunctionName ()

	let done = new Promise(res => window[callBackName] = res)
	let lang = mapComponent.lang
	
	let url = apiUrlWithoutKey+key+"&callback="+callBackName
	
	if(lang)
		url+= "&language="+lang

	lib.setAttribute("src",url)

	mapComponent.shadowRoot.append(lib)

	await done

	delete window[callBackName]
}  

var initMap = function(component,div){
	
	let options = {
        fullscreenControl: false,
        zoom: isNaN(component.zoom) ? 14 : component.zoom ,
        center: toLatLng(component.location),
        mapTypeId: google.maps.MapTypeId.ROADMAP
    }

	return new google.maps.Map(div, options)
}

var toLatLng = function(componentLocation) {
	
	let {latitude, longitude} = componentLocation

	return new google.maps.LatLng(+latitude, +longitude)
}

function randomFunctionName (){
	// Prepend F to be sure that we don't start with a number.
	return  "F"+Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
}




// Private values. WeakMap key and value can be GCed if they are not stored anywhere else.
// Acces any private field using _(this).anyOfyourPrivateField
{
	let map = new WeakMap()

	var priv = function(key) {
		map.set(key,{})
	}

	var _ = function(key) {
		return map.get(key)
	}
}