import Serializer from "./Serializer.js"
import EventHandler from "./EventHandler.js"
import ModuleHandler from "./ModuleHandler.js"
import  * as Coercer from "./Coercer.js"
/**
 @classdesc Base class for component, provide useful methods to get data by attribute and emit data by events.

 @class      ComponentBase

*/
class ComponentBase extends HTMLElement{
	/**
	 * Constructs the ComponentBase,
	 * Do not call, its meant for the DOM.
	 * Remember that as this object is a web component, it's possible to have some attribute already assigned by other pieces of code before the constructor call.
	 */
	constructor(){
		super()
		priv(this)

		_(this).isNew = true
		_(this).destroyed = false

		

		_(this).attributesReaction = {}

		_(this).uid = makeUID.call(this)

		let shmod = getChildShadowMode.call(this,)
		if(shmod != "none"){
			/**
			 * Shadow dom. Open by default
			 * @type ShadowRoot?
			 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot}
			 */
			this.shadow = this.attachShadow({mode : shmod}); 

			appendTemplate.call(this)
			appendStyles.call(this)
		}
		

		initStaticEventHandler.call(this)

	}

	/**
	 * Event called when the custom component have been properly instantiated and added in the DOM.
	 * 
	 * Methods defined in the class may not be available before this event is fired.
	 *
	 * @event      ComponentBase#ready
	 * @type {object}
	 */

 	/**
  	 * function called by the dom when the component if inserted in the dom and ready to be used.
	 * 
	 * You may want to override this one but must call super.connectedCallback() so that the ready event is properly fired.
 	 * @fires ComponentBase#ready
  	 */
	connectedCallback(){

		let rect
		
		if(!this.ready){
			/**
			 * Gets the getBoundingClientRect. This method may return a buffered value of the client rect.
			 * The buffered value is erased when the widow is resized or when {@link resetBox} is called.
			 *
			 * @return     {DOMRect}  The bounding box of this object.
			 */
			this.getBox = () => {
				if(!rect)
					 rect = this.getBoundingClientRect()
				return rect
			}
			
			/**
			 * Reset the buffered dom rect, forcing {@link getBox} to recompute it the next time it's called.
			 *
			 */
			this.resetBox = () => {
				rect = null
			}

			this.constructed = true
			
			window.addEventListener("resize",()=>this.resetBox())

			
			let attribs = serializedAttributes.call(this.constructor)
			reactiveAttributes.call(this,attribs,true)

			let exposed = exposedAttributes.call(this.constructor)
			reactiveAttributes.call(this,exposed,false)

			/**
			 *
			 * True if this component have been initialized and its custom methods are available.
			 *  
			 * @type {boolean?} 
			 * 
			 * @name ready 
			 * 
			 * @readonly
			 * @public
			 * @memberof ComponentBase.prototype
			 * 
			 */
			Object.defineProperty(this,"ready",{writable: false,value:true})
		}
		else
			this.resetBox()

		this.dispatchEvent(new CustomEvent("ready"))
		
	}

	/**
	 * Life cycle callback. Will cause the element to  be destroyed.
	 */
	disconnectedCallback() {
		this.destroy()
	}

	attributeChangedCallback(name,oldValue,newValue){
		if(_(this).attributesReaction[name]){
			_(this).attributesReaction[name].call(this,oldValue,newValue)
		}
	}

	static get observedAttributes(){
		return Object.keys(serializedAttributes.call(this))
	}
	/**
	 * Custom override of add an event listener.
	 * 
	 * Behave as the normal one for all events, with the exception of the "ready" one.
	 * 
	 * The ready event is fired immediately on all added callback. 
	 *
	 * @param      {string}  key     The event name
	 * @param      {function(CustomEvent)}  func    The callback function
	 */
	addEventListener(key,func){
		
		if(key === "ready" && this.constructed){
			let evt = new CustomEvent("ready")

			// Call it in timeout so that it's async in both case.
			setTimeout(func.bind(this),0,evt)
		}else{
			super.addEventListener.apply(this,arguments)
		}
	}

	
	/**
	 * Shorter event listener declaration. The argument of the callback will directly be the event detail and this will be this component
	 *
	 * @param      {DOMString}  key     The key
	 * @param      {function(this:ComponentBase, *)}  func    The  callback function
	 */
	on(key,func){
		this.addEventListener(key,evt => func.call(this,evt.detail))
	}


	/**
	 * Sets the style by adding a <link> or <style> tags in the shadow dom. If
	 * no identifier provided overwrite any  <link> or <style> tags present
	 * directly in the root of the shadow dom. Otherwise only delete the one
	 * with the same id.
	 *
	 * If the chosen tag is <link>, set the href in a timeout 0 so that the code
	 * using the value returned by this function execute before the link start
	 * loading.
	 * 
	 * If styleStr is anything falsy, just proceed to expected deletion without creating any new element.
	 *
	 * @param      {string?}  styleStr  The style string, either plain css of the
	 *                                 path to a css to be linked with a <link>
	 * @param      {Object}  opt_id    The option identifier
	 * @param      {string?}  id      optional identifier. If on provided, the create
	 *                                element will have the id `cb-style-${id}`
	 *                                
	 * @return {HTMLElement?} The created element.
	 * 
	 * @deprecated use the css label instead
	 */
	setStyle(styleStr,opt_id){
		var useID = arguments.length > 1
		
		clearStyles.call(this,opt_id)
		setStyle.call(this,styleStr,useID,opt_id)
	}

	
	/**
	 * Define the mode the shadow dom should be created with.
	 * 
	 * If you inherit ComponentBase, you may override this **static** method.
	 * The meaning of the value is as follow : 
	 *  * **open**  Elements of the shadow root are accessible from JavaScript outside the root, for example using Element.shadowRoot.
	 *  * **closed** Denies access to the node(s) of a closed shadow root from JavaScript outside it. 
	 *  * **none** Do not create a shadow root. Methods that interact with the shadow root will probably not work. Make sens if the component is not visible.
	 * @readonly
	 * @default 'open'
	 * @type {('open'|'closed'|'none')}
	 */
	static get shadowMode(){
		return "open"
	}

	/**
	 * Prevent the component to fire any other event by using _dispatch. Also destroy the static event handler.
	 * 
	 * It recommended for subclasses of ComponentBase to overwrite this method with their own destructor. 
	 * This destructor should call ```super.destroy()``` to be sure that each of the parent class have properly cleaned all the references to themselves they created.
	 */
	destroy(){
		if(_(this).handler){
			_(this).handler.destroy()
		}
		_(this).destroyed = true
	}
	
	/**
	 * Determines if the component have been destroyed.
	 *
	 * @return     {boolean}  True if destroyed, False otherwise.
	 */
	isDestroyed(){
		return _(this).destroyed
	}

	/**
	 * The unique id of this component. Extremely likely to be unique among all
	 * the id of the application.
	 *
	 * The id is made as follow :
	 *
	 * ```JavaScript 
	 * ${name}-${epoch}-${random} 
	 * ``` 
	 * 
	 * Where name is the name of the class of the component, epoch is the date of creation of the component given in ms since the unix epoch and random1
	 * and random is a random integer (about 1e16). The date and random int are encoded on base 16.
	 *
	 * @readonly
	 *
	 * @type       {string}
	 *
	 */
	get uid() {
		return _(this).uid
	}
	/**
	 * Short for this.dispatchEvent(new CustomEvent(evtType,{detail:payload}))
	 * Also check if destroy have been called and cancel the event in this case.
	 * @protected 
	 * @param      {string}  evtType  The event type
	 * @param      payload  The event detail
	 */
	_dispatch(evtType,payload){

		if(_(this).destroyed)
			throw new Error(`Cannot dispatch ${evtType} on component ${this.tagName}. The component have been destroyed.`)
		else
			this.dispatchEvent(new CustomEvent(evtType,{detail:payload}))
	}


	/**
	 * An html string. If provided, this template will be used
	 * to initialize the content of the shadow root during the first connected
	 * callback.
	 *
	 * @abstract
	 * @readonly
	 * @type       {string}
	 */
	static get shadowTemplate(){

	}

	/**
	 * A collection of properties name and their types this component should expose both as js property and serialize as html attribute.
	 * Those properties are inherited from parents and can be overloaded.
	 * Attach triggers to the properties and the attributes , also check if some value have been set before the constructor was called.
	 * 
	 * @abstract
	 * @readonly
	 * @type {Object}
	 */
	static get serialize() {

	}


	/**
	 * A collection of properties name and their types this component should expose both as js property.
	 * Those properties are inherited from parents and can be overloaded.
	 * Attach triggers to the attributes, also check if some value have been set before the constructor was called.
	 * 
	 * @abstract
	 * @readonly
	 * @type {String[]}
	 */
	static get expose() {

	}

	/**
	 * A label function to define the default styles used by a component.
	 *
	 * ### Do not call this function directly, use it as Template literals
	 * tag.
	 *
	 * In order to allow specific override, style can have an id. The value of
	 * the first placeholder is used as the id if this first placeholder is also
	 * the first element of the template string. Template literals without
	 * placeholder or where the first element is not a placeholder will result
	 * in style without id.
	 *
	 * Placeholders that are not the id can also be function, in which case
	 * their first argument will be an instance of the component class. These
	 * function are evaluated only once in the component life cycle : during 
	 * the first connectedCallback, just before the ready event is sent.
	 *
	 * The style string can either be plain css or some URL.
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates
	 *
	 * @example   
	 *
	 * // Style without id. This style cannot be overloaded without removing all the inner styles. 
	 * MyComponent.css` :host { display : block; } ` 
	 * 
	 * // Style  with id, can be overloaded later. 
	 * MyComponent.css`${"colors"} .redThing {background : red; }`
	 *
	 * `// Style with id, and an url.
	 * MyComponent.css`${"layout"}/css/myComponent.css`
	 */
	static css (lines, ...args) {
		let id = ""
		if(lines[0] === "" && args.length){
			id = args[0]
			lines = lines.slice(1)
			args = args.slice(1)
		}
		addStaticCss.call(this,id,lines,args)
		
	}

	/**
	 * A tag function to define the default html content of a component.
	 * 
	 *  
	 * ### Do not call this function directly, use it as a template literal tag.
	 * 
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates
	 * 
	 * @example
	 * class MyComponent extends ComponentBase {
	 * 	// class code ...
	 * }
	 * 
	 * MyComponent.html`
	 * <div class="wrapper">
	 * 	<span class="redThing">${e => e.text}</span>
	 * </div>
	 * `
	 */
	static html (slices, ...args) {
		addStaticTemplate.call(this,slices,args)
	}
	/*
	 * Placeholders can  also be function, in which case their first argument
	 * will be an instance of the component class. These function are evaluated
	 * only once in the component life cycle : during the first
	 * connectedCallback, just before the ready event is sent.
	 *
	 * But I fear such feature encourage bad practices (ie. ignoring attributes
	 * changes) So i don't put it in the doc and recommend to not use this
	 * feature for now.
	 */
}


const loadedTemplate = {}



var getChildShadowMode = function(){
	let c = this.constructor
	while(!c.shadowMode){
		c = getPrototypeOf(c)
	}
	return c.shadowMode
}

/**
 * Define a getter and a setter name name and bind them with the dom
 * attribute with the same name for all element of the static function observedAttributes. If, at the moment where _reactiveAttribute
 * is called the object provide a method named on{$Name}Changed, where
 * {$Name} if the value of name with the first character as Uppercase, then this
 * method will be invoked each time the attribute or the setter are
 * modified.
 */
var reactiveAttributes = function(attribs,serialize){
	
	

	let childrenOwnInits
	if(Array.isArray(attribs))
		childrenOwnInits = attribs.map (attr => {
			return reactiveAttribute.call(this,attr.toLowerCase(),null,serialize)
		})
	else {
		childrenOwnInits = []
		for(let attr in attribs){
			let type = attribs[attr] || ""
			try {
				childrenOwnInits.push(reactiveAttribute.call(this,attr,type,serialize))
			}catch(e) {
				console.error(e)
			}
			
		}
	}

	childrenOwnInits.forEach(i => {
		if(i) {
			i()
		}
	})
}



var reactiveAttribute = function(name,type,serialize){

	let build = attributeBuild.call(this,name,type,serialize)	

	
	if(build.typeString === "module"){
		
		return moduleAttribute.call(this,name,build)

	}
	
	let childInit = null
	

	if(build.serializable){
		addSerializedAcessors.call(this,name,build)
		
	} else {
		addUnserializedAcessors.call(this,name,build)
	}

	setDefaultValue.call(this,name,build)

	Object.defineProperty(this, name, { 
		set: build.set,
		get: build.get
	});

	
			
	return setupChangeReaction.call(this,name,build)
	
}
var addSerializedAcessors = function(name,build) {
	
	bindParseFunction.call(this,"write",build)
	bindParseFunction.call(this,"read",build)
	

	let {read,write} = build

	let provideWrite = !!write


	build.set =  provideWrite 
		? function(x) {
			this.setAttribute(name,write(x))
		} 
		: function(x) {
			this.setAttribute(name,x)
		}
	

	let provideRead = !!read

	build.get = provideRead 
		? function() {
			return read(this.getAttribute(name))
		} 
		: function(x) {
			return this.getAttribute(name)
		}
	
}
var addUnserializedAcessors = function(name,build) {
	if(!("exposed" in _(this))) {
		_(this).exposed = {}
	}

	if(name in _(this).exposed) {
		throw new Error(name + " is either a reserved attribute or is already in use.")
	}

	build.get = function(){return _(this).exposed[name]}

	const useCoertion = !!build.typeString
	const coertion = Coercer[build.typeString]
	if(typeof coertion !== "function")
		throw new Error("Invalid type for exposed property "+name+" : "+build.typeString)

	let setBody = `
		${build.onChange ? "const old = priv[name]":""}
		${useCoertion ? "v = coerce(v)" : ""}
		priv[name]=v
		${build.onChange? "onChange.call(this,old,v)" : ""}
` 
	let scopedArgsName = ["priv","name"] 
	let scopedArgs = [_(this).exposed,name]

	if(useCoertion){
		scopedArgsName.push("coerce")
		scopedArgs.push(coertion)
	}
	if(build.onChange){
		scopedArgsName.push("onChange")
		scopedArgs.push(build.onChange)
	}


	let scopingBody = `	return function(v){${setBody}}`
	let scopingFunction = new Function(...scopedArgsName,scopingBody)

	build.useCoertion = useCoertion
	build.coertion = coertion

	build.set = scopingFunction.apply(null,scopedArgs)

}

var setDefaultValue = function (name,build) {
	if(!build.oldValueExist)
		return
	let initValue = build.initValue

	if(build.serializable) {
		if(!build.isSerialized) {
			initValue = build.write.call(this,initValue)
		}
		this.setAttribute(name,initValue)
	}
	else {
		try {
			if(build.useCoertion){
				initValue = build.coertion(initValue)
			}
			_(this).exposed[name] = initValue
		}catch(e) {
			// We don't set any initial value
			console.error(e)
		}
	}
}

var setupChangeReaction = function (name,build) {
	let init
	
	let read = build.read

	if(typeof build.onChange === "function" ){

		if(build.oldValueExist){

			let oldDeserial = build.isSerialized && read
				? read(build.initValue)
				: build.initValue
			// Return the change callback so that the initialization of other attributes can complete before reaction starts.
			// Avoid issue when reaction read other attributes.
			init = build.onChange.bind(this,null,oldDeserial)
			
			
		}
		
		if(build.serializable){
			_(this).attributesReaction[name] = build.read 
				? function(old,newv) { build.onChange.call(this,read(old),read(newv)) }
				: build.onChange 
		}
		
	}
	return init
}
var bindParseFunction = function(funcName,build) {
	if(typeof build[funcName] === "function"){
		build[funcName] = build[funcName].bind(this)
	}
	else {
		let serializer = build.serializer()
		if(serializer && serializer[funcName] ){
			build[funcName] = serializer[funcName].bind(this)
		}
	}
	
}
var attributeBuild = function (name,type,serializable) {
	let upper_0 = name.charAt(0).toUpperCase() + name.slice(1) 
	let reactionName = "on"+upper_0;
	let readName = "stringTo"+upper_0
	let writeName = name+"ToString"
	let serializer

	let oldValueExist = name in this || serializable && this.hasAttribute(name)
	

	let initValue = serializable && this.getAttribute(name) || this[name]
	
	let isSerialized = serializable && (typeof initValue === "string" ^ type === "string") 

	let typeString, 
		options

	let useTypeObject = false
	if(typeof type === "string") {
		typeString = type
	}else {
		typeString = type.type
		useTypeObject = true
		options = type
		if(!oldValueExist && "v0" in type){
			oldValueExist = true
			initValue = type.v0
		}
	}
	typeString = typeString.toLowerCase()
	return {
		read : this[readName],
		write : this[writeName],
		onChange : this[reactionName],
		serializer : ()=> serializer || (serializer = Serializer(typeString,this,name)),
		serializable,
		oldValueExist,
		initValue,
		isSerialized,
		typeString,
		useTypeObject,
		options
	}
}


var moduleAttribute = function(name,typeBuilder){

	let {initValue,options} = typeBuilder

	let handler = new ModuleHandler(name,options)
	
	let upper_0 = name.charAt(0).toUpperCase() + name.slice(1) 
	let reactionName = "on"+upper_0;

	Object.defineProperty(this, name, { 
		set: v => this.setAttribute(name,v),
		get : ()=> handler.modules
	});

	_(this).attributesReaction[name] = async (oldModulesS,newModulesS) => {

		let oldModules = handler.modules
		try{
			let newModules = await handler.update(newModulesS)

			if(this[reactionName]){
				this[reactionName](oldModules,newModules)
			}
		}catch(e){
			if(!e.isCancelation)
				throw e
		}
		
	}
	this[name] = initValue

}

var isLinkAttribute = function(name) {
	let list  = this.constructor.elementLinks
	if(!list || !list.length)
		return false
	return list.includes(name)
}
var setupAttributeLink = function(name){
	let upper_0 = name.charAt(0).toUpperCase() + name.slice(1) 
	let readName = "stringTo"+upper_0

	let element = null
	this[readName] = function (str) {
		// Will query element each time on browser that do not provide isConnected
		
		if(!(element && element.isConnected))
			element = document.querySelector(str)
		return element
	}
	

	let writeName = name+"ToString"
	this[writeName] = (elem) => {
		var id = typeof elem === "string" ? elem : elem.id
		if(!id)
			throw new Error("Cannot link "+elem+" to "+this.tagName+ " the provided element have no defined id.")
		return "#"+id
	}
}


var serializedAttributes = function(){
	return touchInheritableObj.call(this,"serialize")
}

var exposedAttributes = function(){
	let expose = priv(this).expose
	if(!expose) {
		expose = buildInheritableObj.call(this,"expose")
		let serial = serializedAttributes.call(this)
		for(let key in serial) {
			delete expose[key]
		}
		priv(this).expose = expose
	}
	return expose
}

var touchInheritableObj = function(name) {
	return priv(this)[name] || (priv(this)[name] = buildInheritableObj.call(this,name))
}
var buildInheritableObj = function(name){
	let serz = []
	let prot = this
	do{
		let attributes = prot[name]
		if(attributes){
			if(Array.isArray(attributes)) {
				let map = {}
				attributes.forEach(a => map[a] = undefined)
				attributes = map
			}
			serz.push(attributes)
		}
		prot = Object.getPrototypeOf(prot)
	}while(prot && prot !== ComponentBase)

	serz.reverse()

	if(!serz.length)
		return {}

	return Object.assign.apply(null,serz)
}
var initStaticEventHandler = function(){
	let hCode = this.getAttribute("handlers")
	if(hCode){
		try{
			let h = new EventHandler(this)

			_(this).handler = h

			h.setCode(hCode)

		}catch(e){
			console.error("Failed to parse static event handler, cause : ")
			console.error(e)

			if(_(this).handler){
				_(this).handler.destroy()
				_(this).handler = null
			}
			
		}
		
	}

}

var appendTemplate = function(){
	let {template} = priv(this.constructor)

	if(template){
		
		this.shadow.innerHTML += template(this)
	}
}
var appendStyles = function(){
	const {shadowStyles} = priv(this.constructor)
	if(shadowStyles){
		for(let key in shadowStyles) {
			setStyle.call(this,shadowStyles[key](this),key !== "", key)
			
		}
	}
}

const clearStyles = function(id) {
	var rmSelector = id ? `#cb-style-${id}` : `link[type="text/css"],style`
	let toRemove = this.shadow.querySelectorAll(rmSelector)

	for(var r of toRemove){
		r.remove()
	}
}

const setStyle = function setStyle(styleStr,useID,id){
		let isFileRef = styleStr.match(/^\.?\//g)
		var styleElem

		
		var rmSelector = useID ? `#cb-style-${id}` : `link[type="text/css"],style`
		let toRemove = this.shadow.querySelectorAll(rmSelector)

		for(var r of toRemove){
			r.remove()
		}

		if(!styleStr){
			return
		}

		if(isFileRef){
			styleElem = document.createElement('link');
			styleElem.setAttribute("rel","stylesheet")
			styleElem.setAttribute("type","text/css")

			// Set the href in a timeout so that calling method may listen to
			// event of style sheet of set additional parameter before the  load
			// start
			setTimeout(()=> styleElem.setAttribute("href",styleStr), 0);
			
		}
		else{
			styleElem = document.createElement('style');
			styleElem.innerHTML = styleStr.replace(/\s+/g," ")
		}
		
		if(useID)
			styleElem.id = `cb-style-${id}`

		this.shadow.appendChild(styleElem)

		return styleElem
	}
// ****************************************************************************
// *                              Static Private                              *
// ****************************************************************************

var addStaticTemplate = function(slices, args) {

	let template = priv(this).template
	
	if(template)
		return template
	
	
	template =  parseTemplate(slices, args)
	priv(this).template = template

}

const addStaticCss = function(name,cssSlices, args) {
	let shadowStyles = priv(this).shadowStyles
	if(!shadowStyles) {
		shadowStyles = {}
		priv(this).shadowStyles = shadowStyles
	}

	if(name in shadowStyles){
		throw new Error("Class "+this.name+" already have a static style "+name)
	}
	shadowStyles[name] = parseTemplate(cssSlices, args)
	
}

var makeUID = function (){
	let n = this.constructor.name
	let d = Date.now().toString(16)
	let r = (Math.round(Math.random()*1e16)).toString(16)

	return `${n}-${d}-${r}`

}






const checkHTMLLines = function(lines) {
	if(lines.length > 1) {
		throw new Error("The html template string do not allows parameters")
	}


}

const parseTemplate = function(slices,values) {
	const evalv = (index,instance) => 
		index >= values.length
		? ""
		: typeof values[index] === "function" 
			? values[index](instance)
			: String(values[index])
	return instance => {
		return slices.map((s,i) => s+evalv(i,instance)).join("")
	} 
}

 // Private values. Weakmap key and value can be GCed if they are not stored anywhere else.
{
	let map = new WeakMap()

	var priv = function(key) {
		let v = map.get(key)
		if(!v) {
			v = {}
			map.set(key,v)
		}
		return v
	}

	var _ = function(key) {
		return map.get(key)
	}
}

export default ComponentBase
