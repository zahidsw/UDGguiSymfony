
import ComponentsBase from "/node_modules/componentBase/index.js"
import toDrawQuery from "./toDrawQuery.js"
import Capacitor from "/node_modules/Capacitor/index.js"

/**
 * Base class for other icon components. Allow to display parametrized image.
 *
 * Component class deriving for this one have two way of displaying image.
 *
 * #### Local rendering
 *
 * Class providing a static attribute {@link template} will be rendered locally
 * as long as no external process change their src attribute.
 *
 * Locally rendered ParametricIcon put their image in a blob. This can be accessed
 * through the src attribute of the ParametricIcon. This URL is revoked as soon as
 * the image is modified either by changing the source or on of the parameter.
 *
 * #### Remote rendering
 *
 * Class that do not provide a static attribute {@link template} are rendered
 * remotely. An instance of a class with a local template will also be rendered
 * remotely if its src attribute is modified by any external process.
 *
 * When rendering remotely, the instance of ParametricIcon will request the image at
 * the url given by it's src attribute.
 *
 * When changing the attributes of a remotely rendered image, the image will
 * change the query string of its src to pass those attribute to the service in
 * charge of the rendering.
 *
 * For class with as template property, setting the src to the empty string will
 * make the image start to render locally.
 *
 * @property   {string}  src     The URL of the image. Point either to a blob or
 *                               to a distant resource. Directly changing this
 *                               value will cause the image to assume the image
 *                               is rendered remotely. When delegating the
 *                               rendering, this component will put the image
 *                               parameter in the query part, overwriting any
 *                               other eventually preexisting query.
 * @abstract
 *
 * @class      ParametricIcon
 */
class ParametricIcon extends ComponentsBase {
	
	constructor(){
		super()
		priv(this)
		_(this).scheduleUpdate = Capacitor(update)
			.delay(10)
			.interval(200)
			.bind(this)
	}

	connectedCallback(){
		
		if(!"rendering" in this)
			this.rendering = "local"
		
		if(!this.ready) {
			createImage.call(this)

			this.constructor.imageParameters.forEach( p => {

				let name = "on"
					+ p.charAt(0)
					   .toUpperCase()
					+ p.slice(1)

				if(!(name in this)) {
					this[name] = _(this).scheduleUpdate
				} 

			})

			if(!this.constructor.isLocal && ! ("onSrc" in this)){
				this.onSrc = _(this).scheduleUpdate
			}

			if(this.constructor.useColorScheme && ! ("onColorscheme" in this)){
				this.onColorscheme = _(this).scheduleUpdate
			}

			
		}
		this.setStyle("#iconImage{height:100%;width:100%}","iconImage")
		super.connectedCallback()
	}

	onSrc(ol,nu){
		if(nu !== _(this).localURL){
			clearLocalImage.call(this)
		}
		if(ol !== nu && !this.isLocal) {
			this.rerender()
			return
		}
		_(this).image.src = nu
	}
	/**
	 * Redo the rendering.
	 */
	rerender(){
		_(this).scheduleUpdate()
	}

	/**
	 *
	 * @type {boolean}
	 * @readonly
	 * @desc
	 * If true, this icon is be rendered locally in a blob.
	 */
	get isLocal (){
		let haveURL = !!_(this).localURL
		let haveSRC = !!this.src
		let haveTemplate = "template" in this.constructor

		return haveTemplate && !(haveURL ^ haveSRC)
	}


	/**
	 * Subclasses of ParametricIcon may get this value in the serialize getter.
	 * The object setup the following attributes if relevant : 
	 *  - **colorscheme** if the base class declared to use a color scheme
	 *  - **all the parameters** declared through imageParameters as a string.
	 * @readonly
	 * @type {Object}
	 * 
	 */
	static get standardSerial(){
		
		let base = {} 
		
		
		if(this.useColorScheme){
			base.colorscheme = {
				type : "module",
				cardinality : "one",
				externalsOwner : this,
				defaults:{}
			}
		}

		this.imageParameters
			.forEach(ip => base[ip] = "string")
		
		return base
	}

	static get serialize() {
		return {
			src:"string"
		}
	}
	/**
	 * @abstract
	 * @type       {String[]}
	 * @desc
	 * The list of attribute that should be used as template parameters.
	 * Those attribute also need to be returned by the serialize method of the class extending ParametricIcon.
	 * 
	 * Changing those attributes or properties will cause an update of the icon
	 * to be scheduled. If many of these attribute are changed at once on a same
	 * thread, the update will occur only once. This update scheduling is base
	 * on the Capacitor wrapper.
	 * 
	 * 
	 * 
	 * @see https://gitlab.distantaccess.com/turien/capacitor
	 */
	static get imageParameters() {

		return []
	}
	
	static get shadowMod(){
		return "open"
	}

	/**
	 * @abstract 
	 * 
	 * @desc
	 * Return additional template argument for template argument that are computed by
	 * the icon itself. Those value override the ones provided by the attribute declared as image parameters.
	 *
	 * #### Optional
	 *
	 * @return     {Object.<string,string>}  The internal arguments and their value.
	 */
	getInternalArgs(){
		return {}
	}

	/**
	 * Gets the color from the color scheme of this component. Available only if
	 * this class have {@link useColorScheme} set to true.
	 *
	 * @param      {string}     expor   The name of the exported color section
	 * @param      {string?}    name    name of the color in the exported
	 *                                  object. If null return the exported
	 *                                  object.
	 * @return     {HTMLColor}  The color as a a string
	 */
	getColor(expor,name) {
		if(!this.constructor.useColorScheme)
			throw new Error("This object do not use colorscheme")

		return getSchemeColor(this.colorscheme,expor,name)
	}



	/**
	 * Locally create the image of this class in a blob. As the the parameters
	 * will mos likely be inlined in some xml, all the the string passed in
	 * argument have the following character replaced by their html escape
	 * sequences : 
	 * 
	 * 	<>&;
	 *
	 * @param      {Object}  imageArgs  The arguments to apply on the template
	 *
	 * @return     {Blob}  The created image in a Blob.
	 */
	static createLocaly(imageArgs) {
		let svg = this.template(escapeStringArgs(imageArgs))
		const blob = new Blob([svg], {type: 'image/svg+xml'})
		return blob
	}

	destroy(){
		clearLocalImage.call(this)
	}
	/**
	 * 
	 * @readonly
	 * @abstract
	 * @function ParametricIcon#template
	 * 
	 * @desc A template to use for icon that render locally. If not provided, the rendering of the image will be deferred to the server.
	 * 
	 * #### Optional
	 */

	 
	/**
	 * @readonly
	 * @static
	 * @abstract
	 * 
	 * @prop ParametricIcon#useColorScheme
	 * 
	 * @type {boolean}
	 * 
	 * @memberof! ParametricIcon
	 * 
	 * @desc 
	 * If true, add a colorscheme module attribute. It enable the use of the {@link getColor} function.
	 * 
	 * #### Optional
	 */
}

// ****************************************************************************
// *                                    DOC                                   *
// ****************************************************************************
/**
 * 
 * @readonly
 * @abstract
 * @function ParametricIcon#template
 * 
 * @desc A template to use for icon that render locally. If not provided, the rendering of the image will be deferred to the server.
 * 
 * #### Optional
 */

 
/**
 * @readonly
 * @static
 * @abstract
 * 
 * @name useColorScheme
 * 
 * @type {boolean}
 * 
 * @memberof ParametricIcon
 * 
 * @desc 
 * If true, add a colorscheme module attribute. It enable the use of the {@link getColor} function.
 * 
 * #### Optional
 */


// ****************************************************************************
// *                                 Privates                                 *
// ****************************************************************************


/**
 * @ignore
 */
const update = function(){
	// We assume that the colorscheme is not yet loaded.
	if(this.constructor.useColorScheme && !(this.colorscheme))
		return

	let local = this.isLocal 
	
	if(!local && !this.src)
		return 
	let args = getImageArgs.call(this)

	
	let updateImage = local
		? updateImageLocal
		: updateImageRemote

	updateImage.call(this,args)

}

const createImage = function() {
	let image = this.shadowRoot.getElementById(imageID)
	
	if(image)
		image.remove()

	image = ( 
		this.constructor.isLocal ?
			createImageLocal :
			createImageRemote
	).call(this)
	

	image.id = imageID

	this.shadowRoot.append(image)
	_(this).image = image
	_(this).scheduleUpdate()
}

const updateImageLocal = async function(arg) {
	
	clearLocalImage.call(this)
	const blob = this.constructor.createLocaly(arg)
	const url = URL.createObjectURL(blob)
	_(this).localURL = url
	
	this.src = url
}

const updateImageRemote = function(arg){
	this.src = toDrawQuery(this.src.split("?")[0], arg)
}

const createImageLocal = function(){

	let svg = document.createElement("img");
	return svg
}

const createImageRemote = function(){
	let img = document.createElement("img");
	return img
}


const getImageArgs = function(){
	let params = this.constructor.imageParameters
	let base = this.getInternalArgs() 

	return params
		.filter(p=>!(p in base))
		.reduce(
			(acc,p) => (acc[p] = this[p], acc) ,
			base
		)
}
const clearLocalImage = function(){
	if(_(this).localURL){
		URL.revokeObjectURL(_(this).localURL)
		_(this).localURL = undefined
	}
}

// ****************************************************************************
// *                              Static Private                              *
// ****************************************************************************
const localSVGURL = "data:image/svg+xml;base64,"
const imageID = "iconImage"
const templateStore = {}
const nsSVG = "http://www.w3.org/2000/svg"

const getTemplate = async function (path) {
	
	if(path in templateStore) {
		// This may either be a Template or a promise of template but as this
		// function is async, the returned object is alway a promise of
		// template.
		return templateStore[path]
	}
	else {

		let promise = loadTemplate(path)
		
		templateStore[path] = promise
		

		return promise
	}
}

const loadTemplate = async function(path) {
	let req = new XMLHttpRequest()

	req.open("GET",path,true)

	let p = new Promise(res => req.onload = res)
	req.setRequestHeader("Accept","image/svg+xml; charset=utf-8")

	req.send()

	await p

	let t = new Template(req.responseText)

	templateStore[path] = t

	return t
}


const getSchemeColor = function(scheme,path,name) {
	
	if(!(path in scheme)){
		console.error("Your color scheme is missing the "+path+" part")
		return "magenta"
	}

	let p = scheme[path]
	if(name === undefined){
		return p
	}
	if(!(name in p)){
		console.error("The part "+path+" of the colorscheme is missing the entry "+name)
		return "magenta"
	}

	return scheme[path][name]
}

const escapeChar = /[<>&;]/g

const escapeStringArgs = function(args){
	let escapeds = {}
	for(let key in args) {
		let value = args[key]
		let escaped = value
		if(typeof value === "string") {
			escaped  = value.replace(escapeChar,function(s){return `&#${s.charCodeAt()};`})
		}
		escapeds[key] = escaped
	}

	return escapeds
}

function guessMeta() {
	let str = 
`
	${this.name} : {
${Object.entries(this.serialize)
	.map(([key,value])=>
`		${key} : {
			default : ${mostLikelyDefault(key)},
			type : "${mostLikelyInput(key)}"
		}`
	).join(",\n")
}
	}
`
return str
}

function mostLikelyInput(name) {
	if(name.includes("stroke") || name.includes("fill") || name.includes("color"))
		return "color"
	if(name.includes("val") || name.includes("opacity") || name.includes("height") || name.includes("length")|| name.includes("percent"))
		return "number"
	return "text"
}
function mostLikelyDefault(name) {
	if(name.includes("stroke") || name.includes("fill") || name.includes("color"))
		return `"${randColor()}"`
	if(name.includes("val") || name.includes("opacity") || name.includes("height") || name.includes("length")|| name.includes("percent"))
		return 0
	return '"text"'
}
function randColor(){
	let randHex = ()=>Math.round(Math.random() * 255).toString(16).padStart(2,"0")
	return "#"+randHex()+randHex()+randHex()
}
// Private values. Weakmap key and value can be GCed if they are not stored anywhere else.
// Acces any private field using _(this).anyOfyourPrivateField
{
	let map = new WeakMap()

	var priv = function(key) {
		map.set(key,{})
	}

	var _ = function(key) {
		return map.get(key)
	}
}


export default ParametricIcon
