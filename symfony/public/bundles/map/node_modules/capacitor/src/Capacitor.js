/**
 * Do not use **new**.
 * 
 * Wrap the callback function in a capacitor function. Return you a new function that can be called with the same argument as the wrapped function.
 * The return function can also be given a delay value, a interval value and an aggregation function.
 * The this in the callback function will be the same as the one used to call the capacitor.
 * 
 * When the capacitor function is invoked, it will either propagate the call to the wrapped function, discard the call or aggregate the call argument.
 * 
 * * If the capacitor is not waiting and the delay is 0, it will forward the call to the wrapped function. 
 *  * If a interval have been set, the capacitor will also start waiting for this duration. 
 * * If the capacitor is not waiting and the delay is not 0, the capacitor will start waiting for the duration of the delay.
 * 
 * * If the capacitor is waiting, it will store the argument of the call and call the wrapped function once at the end of it's wait.
 * 
 * By default, it the capacitor is invoked multiple time while waiting, the call at the end of the wait period will be done with the last provided argument.
 * In the case a aggregator have been provided, the wrapped function will be called with the aggregation of all the arguments passed in all the invocation of the Capacitor during this waiting time.
 * @class Capacitor 
 * @param      {Function}  callback    The function to wrap.
 * @return     {Capacitor}    A function as described above.
 */
function Capacitor(callback){

		
	let aggregator = (buff,arg)=> arg

	const wait = (t)=> t ? 
		new Promise(res=>isWaiting = setTimeout(res, t)).then(() => isWaiting = false) : 
		Promise.resolve()

	let minInterval = 200;
	let isWaiting = false;
	let delay = 0
	let buffer = undefined
	let wasCalled = false
	
	
	var f = async function(){
		/**
		 * @instance
		 */
		 
		// Alway aggregate
		buffer = aggregator(buffer,...arguments)
		wasCalled = true
		// If a callback is already scheduled, just it take care of the data we buffered.
		if(isWaiting){
			return;
		}


		// handling delay
		//Wait for the delay to finish
		if(delay)
			await wait(delay)

		try{
			//pass buffer to callback
			callback.call(this,buffer)
		}catch(e){
			console.error(e)
		}

		// minimal interval

		wasCalled = false

		if(minInterval)
			await wait(minInterval)

		// As long as the function was called during the pause interval, we schedule a check at the end of the pause.
		while(wasCalled){
			
			try{
				callback.call(this,buffer)
			}catch(e){
				console.error(e)
			}

			buffer = undefined
			wasCalled = false

			if(minInterval)
				await wait(minInterval)
		}
		

		wasCalled = false
		buffer = null

		
	}

	/**
	 * Set the delay of this capacitor. This value is 0 if not set.
	 * 
	 * When called, a capacitor with a positive delay will start a wait period for the duration of the delay and invoke the wrapped method at its end.
	 * All subsequent invocation occurring during the wait time, are either discarded or aggregated.
	 *
	 * @memberof Capacitor 
	 * @instance
	 * @name delay
	 * @function
	 * 
	 * @param      {number}  length  The duration of the delay in ms
	 */
	f.delay = function(length){

		delay = length;
		return f;
	}

	/**
	 * Set the interval of this capacitor. This value is 200 ms if not set.
	 * 
	 * When called, a capacitor with a positive interval will call its wrapping function immediately or after the end of the delay (if any), the enter a waiting period of the specified duration.
	 * All subsequent invocation occurring during the wait time, are either discarded or aggregated.
	 * 
	 * @memberof Capacitor
	 * @instance
	 * @name interval
	 * @function
	 * 
	 * @param      {number}  length  The duration of the interval in ms
	 */
	f.interval = function(length){
		minInterval = length;
		return f;
	}

	/**
	 * The aggregation function, used to combine the arguments passed by the call of the capacitor that occurred during a same wait period.
	 * @memberof Capacitor
	 * @callback Capacitor~aggregator
	 * @param buffer the value return by the precedent call to this function of null if this function is called for the first time for this waiting phase.
	 * @param {...*} callArguments the argument used to call the capacitor.
	 * @return {Object} an object that will be passed as first argument to the next call to this aggregator or as first argument of the wrapped function
	 */

	/**
	 * Specify how to combine the argument
	 * @name aggregator
	 * @function
	 * @memberof Capacitor 
	 * @instance
	 * @param      {Capacitor~aggregator}  agg     The aggregating function
	 */
	f.aggregator = function(agg){
		aggregator = agg;
		return f;
	}
	return f
}


export default Capacitor