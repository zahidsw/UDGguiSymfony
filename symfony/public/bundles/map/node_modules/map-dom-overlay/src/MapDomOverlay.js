
import {MapElement} from "/node_modules/map-component/index.js"
import {toNodeId} from "./toNodeId.js"

import {getAddapterClass,create} from "./DomOverlayAddon.js"

/**
 * Class for a custom component usable as a DOM based overlay for a variety of map library. 
 * This component will take care of displaying at the right place geolocalized nodes. 
 * 
 * Will this approach allow a lot of freedom in term of customization, it also require more resources than other solution provided by map library.
 * 
 * The use of a custom hook will be required to add the overlay to the map.
 * 
 * This component react to the change of attribute of its children.
 * 
 * @class      MapDomOverlay 
 * 
 * @prop {MapDomOverlay~Positioning} [positioning="style"] The way this component will use to pass their position to its child.
 * @prop { MapDomOverlay~Sizing} [sizing="style"] The way this component will use to pass their size to its child.
 */
class MapDomOverlay extends MapElement{
	
	constructor(){
		super()
		priv(this)

		let slot = document.createElement("slot")
		this.shadow.appendChild(slot)
		_(this).slot = slot
		_(this).onZoom = onZoom.bind(this)
		_(this).onWindowResize = onWindowResize.bind(this)
		window.addEventListener("resize",_(this).onWindowResize )
		let ownObserver = new MutationObserver(onChildlistChanged.bind(this))
		_(this).ownObserver = ownObserver

		ownObserver.observe(this,{childList:true})
	}

	connectToMap(){

		_(this).adapter = this.mapComponent.adapter

		create(_(this).adapter,this.mapComponent,_(this).adapter.mapObject)

		setSlot.call(this)
		
		this.place()
		this.setStyle(":host{position : relative}","domOverlay")
		

		this.mapComponent.addEventListener("map_zoom", _(this).onZoom)

		for(let c of this.children)
			onChildAdded.call(this,c)
	}

	
	static get serialize(){
		return {
			positioning : {
				type : "string",
				v0 : "style"
			},
			animate_scale : {
				type:"boolean",
				v0 : false
			},
			sizing : {
				type:"string",
				v0 : "style"
			}
		}
	}
	
	static get shadowMod(){
		"open"
	}

	/**
	 * Update the screen position of each child element.
	 * 
	 */
	place() {
		let loc = this.mapComponent.location
		
	
		_(this).referenceLocation = this.mapComponent.location
		place.call(this,true)
	}

	


	destroy(){

		try {
			window.removeEventListener("resize",_(this).onWindowResize )
		
			for(let child of _(this).slot.childNodes){
				
				let obs = priv(child).observer
				if(obs)
					obs.disconnect()

			}

			this.mapComponent.removeEventListener("map_zoom", _(this).onZoom)
		}catch(e) {
			console.error(e)
		}
		super.destroy()
		

	}
}


// ****************************************************************************
// *                              Additional Doc                              *
// ****************************************************************************

/**
 * The type of data that can be used to create and update children of the MapDomOverlay.
 * 
 * @typedef {Object} MapDomOverlay~PoI
 * 
 * @prop {string} type The type of the poi. Used to define the kind of marker to use to display it.
 * 
 * @prop {object} location The location of the PoI
 * @prop {number} location.latitude The latitude of the PoI given in decimal degree.
 * @prop {number} location.longitude The longitude of the PoI given in decimal degree.
 *  
 */

/**
 * @typedef    {("property"|"variable"|"attribute")}  MapDomOverlay~Positioning
 *
 * The way this component will use to pass their position to its child.
 * 
 *  - **style** : When updating, this overlay will place its child by setting
 *    the css property left and top. It will also set the position of the
 *    element to absolute.
 *    
 *  - **variable** : When updating, this overlay will define the value of the
 *    css variable --left and --top on each of its child. The css rule applied
 *    to the child have to use those variable to place them properly. Note that while the variable are given in css pixel,
 *    they do not have the suffix pixel. The reason is that adding this suffix
 *    will prevent those value to be used in certain calc() expression. To
 *    simply use the value in a css proerty as a pixel length, put it in a calc
 *    and multiply it by 1 of this unit. **example** : top : calc(1px * var(--top)); left : calc(1px * var(--left) + 2em)
 *    
 *  - **attribute** : When updating, this overlay will update the screenLocation
 *    attribute of JS object of each of its child. The value of this attribute
 *    will be a {@link MapDomOverlay~ScreenPosition} where x and y property
 *    define where in the map-dom-overlay the child should be drawn by some
 *    other piece of code.
 */
/**
 * @typedef    {("property"|"variable"|"attribute")}  MapDomOverlay~Sizing
 *
 * The way this component will use to pass their size to its child.
 *  - **style** : When updating, this overlay will place its child by setting
 *    the css property width and height. It will also set the display of the
 *    element to block.
 *  - **variable** : When updating, this overlay will define the value of the
 *    css variable --overlay-size-x and --overlay-size-y on each of its child. The css rule applied
 *    to the child have to use those variable to place them properly.
 *  - **attribute** : When updating, this overlay will update the screenSize
 *    attribute of JS object of each of its child. 
 */
/**
 * An object representing some position in the space of the user screen.
 * 
 * @typedef {Object} MapDomOverlay~ScreenPosition
 * 
 * @prop {number} x The x coordinate, in css pixel.
 * @prop {number} y The y coordinate, in css pixel.
 * 
 */


/**
 * 
 * @abstract
 * @class MapDomOverlay~MapAdapter
 * 
 * 
 * @desc
 * When instantiating a new MapAdapter, the {@link DomOverlayAddon} will expect this constructor signature.
 * 
 * @param      {MapComponent}   mapComponent  The map component hosting
 *                                            domOverlay
 * @param      {MapDomOverlay}  domOverlay    The dom overlay this adapter is
 *                                            destined to.
 *                                             
 * @classdesc
 * An interface for objects creating a slot in the shadow dom of a MapComponent for a given map library.
 * 
 * 
 * 
 */

/**
 * The name of the slot created for the MapDomOverlay
 * @readonly
 * 
 * @name MapDomOverlay~MapAdapter#slotName
 * @abstract
 * @property  { String } 
 * 
 */


// ****************************************************************************
// *                                 Privates                                 *
// ****************************************************************************

// default zoom transition duration 
const defZoomTrDur = 400

//default zoom transition (css)
const defZoomTr = `left ${defZoomTrDur}ms linear, top ${defZoomTrDur}ms linear, height ${defZoomTrDur}ms linear, width ${defZoomTrDur}ms linear`
console.log(defZoomTr)

const defaultSizing = "variable"
/**
 * Create a slot for give MapDomOverlay inside a map-component and assign this overlay to the slot.
 * The domOverlay must be a direct child of a map component when this method is called.
 * 
 * @private
 */
var setSlot = function(){

	let mapComponent = this.parentNode
	
	let engine = mapComponent.poweredby

	let adapter = new mapComponent.domOverlay.Adapter(mapComponent,this)
	let slotName = adapter.slotName

	this.slot = slotName
	_(this).ownAdapter = adapter
	
}

var setPxPos = function(child,pxPos,positioning) {
	if(positioning === "style"){
		
		let style = child.style
		style.left = pxPos.x+"px"
		style.top = pxPos.y+"px"
		style.position = "absolute"

	}else if(positioning === "variable") {
		
		let style = child.style
		style.setProperty("--left", pxPos.x)
		style.setProperty("--top", pxPos.y)
	
	}else if(positioning === "attribute") {
		
		child.screenLocation = pxPos
	
	}else {
		throw new Error("Unknown positioning mode "+positioning)
	}
}

var setSize = function(child,sizex,sizey,sizing) {
	if(sizing === "style" ) {
		let style = child.style
		style.width = sizex+"px"
		style.height = sizey+"px"
		style.position = "absolute"
		style.display = "block"
	}
	else if(sizing === "variable") {
		child.style.setProperty("--overlay-size-x",sizex)
		child.style.setProperty("--overlay-size-y",sizey)
	}
	else if(sizing === "attribute") {
		child.screenSize = {x:sizex,y:sizey}
	}else {
		throw new Error("Unknown sizing mode "+sizing)
	}
}

var place = function(preventTransition) {
	for(let child of managedNodes.call(this)){
		
		try {
			placeNode.call(this,child,preventTransition)

		}catch(e){
			console.error(e)
		}

	} 
}
var placeNode = async function(node,preventTransition,useRef) {
	
	if(!_(this).adapter){
		return
	}

	let positioning = this.positioning
			
	if(node.hasAttribute("parent-positioning")) {
		
		positioning = node.getAttribute("parent-positioning")
		if(positioning === "none")
			return

		
	}

	const setSize = node.getAttribute("south-bound")||node.getAttribute("west-bound")
	let sizing = this.sizing

	if(node.getAttribute("parent-sizing")) {
		sizing = node.getAttribute("parent-sizing")
	}

	let latitude = +node.getAttribute("latitude")
	let longitude = +node.getAttribute("longitude")

	let pxPos = computePxPos.call(this,latitude,longitude,useRef)
	
	

	
	if(preventTransition){
		node.style.transition = "none"
	}

	setPxPos(node,pxPos,positioning)
	
	if(setSize)
		setPxSize.call(this,node,pxPos,sizing,useRef)

	if(preventTransition){
		await wait(20)
		node.style.transition = ""
	}
		
}

var computePxPos = function(latitude,longitude,useRef) {

	if(useRef){
		// Use a reference location so that map viewport modification can be applied by 
		// setting a transform to the whole overlay when relevant (like during dragging)
		// The position of component moving while a transform is applied will still be 
		// placed at the right location as reference location do not change with the 
		// transform.
		let ref = _(this).referenceLocation

		return _(this).adapter.latLngToComponentPx({latitude,longitude},ref)
	}else {
		return _(this).adapter.latLngToComponentPx({latitude,longitude})
	}
	
}

var setPxSize = function(node,pxPos,sizing,useRef) {
	
	const south = node.hasAttribute("south-bound")
		? +node.getAttribute("south-bound")
		: +node.getAttribute("latitude")

	const west = node.hasAttribute("west-bound") 
		? +node.getAttribute("west-bound") 
		: +node.getAttribute("longitude")

	const swPxPos = computePxPos.call(this,south,west,useRef)
	const targetHeight =  swPxPos.y - pxPos.y
	const targetWidth = swPxPos.x - pxPos.x


	setSize.call(this,node,targetWidth,targetHeight,sizing)
}

var managedNodes = function(){

	return this.querySelectorAll(':scope > :not([parent-positioning="none"])')
}
var onZoom = function (){

	let nodes = managedNodes.call(this)

	nodes.forEach(n=> n.style.transition = defZoomTr)
	place.call(this,false)
	setTimeout(
		()=> nodes.forEach(n=> n.style.transition = ""),
		defZoomTrDur
	)

}



var onChildAttributeChanged = function(node,mutationsList) {
	let relocate = false
	for(var mutation of mutationsList) {
		let attr = mutation.attributeName
		if(attr === "latitude" || attr === "longitude"){
			relocate = true;
			break;
		}
    }
    if(relocate)
    	placeNode.call(this,node,false,true)
}

var onChildlistChanged = function (mutationsList) {
	for(let mutation of mutationsList) {
		if(mutation.type === "childList") {
			for(let added of mutation.addedNodes){
				onChildAdded.call(this,added)
			}
			for(let removed of mutation.removedNodes){
				onChildRemoved.call(this,removed)
			}
		}
	}
}

var onChildAdded = function(node) {
	let observer = priv(node).observer
	
	if(observer)
		observer.disconnect()

	observer = new MutationObserver(onChildAttributeChanged.bind(this,node))

	_(node).observer = observer

	observer.observe(node,{"attributes" : true})


	placeNode.call(this,node,true)


}

var onChildRemoved = function(node) {
	let observer = priv(node).observer
	
	if(observer)
		observer.disconnect()
}

var onWindowResize = function() {
	place.call(this,true)
}
var wait = function(t){
	return new Promise(res => setTimeout(res, t))
}
// Private values. Weakmap key and value can be GCed if they are not stored anywhere else.
// Acces any private field using _(this).anyOfyourPrivateField
{
	let map = new WeakMap()

	var priv = function(key) {
		let args = {}
		map.set(key,args)
		return args
	}

	var _ = function(key) {
		return map.get(key)
	}
}


export default MapDomOverlay
