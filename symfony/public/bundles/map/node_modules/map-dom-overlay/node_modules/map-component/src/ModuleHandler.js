export default class ModuleHandler {
	constructor(name,options) {

		let {defaults, externalsOwner,cardinality,externalName} = options
		
		this.defaults = defaults

		this.externalsOwner = externalsOwner
		
		this.externalName = externalName || "external"+name.charAt(0).toUpperCase()+name.slice(1)

		initExternal(externalsOwner,externalName)

		externalsOwner[this.externalName] = new Proxy(this.externals,{set : addExternalModule})

		this.cardinality = cardinality || "one"
		this.oldModuleString = ""
		this.modules = null
		this.name = name


	}
	get externals(){
		return _(this.externalsOwner)
	}
	async update(moduleString){
		
		this.updateKey = Math.random()+""+Date.now()

		if(this.oldModuleString === moduleString)
			return

		this.oldModuleString = moduleString

		this.modules = null

		let splitted = moduleString.split(splitRule)
			.map(s => s.trim())
			.filter(s => s)
		
		checkCardinality.call(this,splitted)

		if(this.cardinality === "one"){
			this.modules = await loadModule.call(this,splitted[0])
		}else{
			this.modules = await Promise.all(splitted.map(loadModule.bind(this)))
		}

		return this.modules

	}
}

const splitRule = /(?:\n\r?|,|;)+/



var checkCardinality = function(splitted){
	if(this.cardinality === "one" && splitted.length > 1){
		throw new Error("Invalid module set "+this.name+" : ["+splitted.join()+"], only one allowed.")
	}
}

var initExternal = function(externalsOwner,externalName){
	

	if(!externalsOwner[externalName])
		externalsOwner[externalName] = new Proxy(priv(externalsOwner),{set : addExternalModule})
}
var loadModule = async function(moduleName){
	
	if(isPath(moduleName))
		return await import(moduleName)
	if(haveExeternal.call(this,moduleName))
		return this.externals[moduleName]
	if(this.defaults && moduleName in this.defaults)
		return this.defaults[moduleName]

	return waitForExternal.call(this,moduleName)
}

var isPath = function(str){
	return str.includes("/")
}

var haveExeternal =function(name){
	return this.externals[name] && this.externals[name] !== "function"
}
var waitForExternal = async function (moduleName) {
	let updateKey  = this.updateKey 

	let p
	if(this.externals[moduleName])
		p = this.externals[moduleName].promise

	p = new Promise(res => this.externals[moduleName] = res)
	this.externals[moduleName].promise = p

	let res = await p

	if(updateKey != this.updateKey)
		throw new ExternalLoadCanceled()

	return res
}

var addExternalModule = function (obj,name,value){
	if(typeof obj[name] === "function"){
		let callback = obj[name]
		obj[name] = value
		callback(value)
	}
	else{
		if(obj[name])
			throw new Error(this.name+" already have a module "+name)
		obj[name] = value
	}

	return true
}


//
// Thrown when the handler was waiting for some external but the set of module
// to change have changed, and so this update process should be aborted.
//
// @class      ExternalLoadCanceled 
//
class ExternalLoadCanceled extends Error{
	constructor(){
		this.isCancelation = true
	}
}

// Private values. Weakmap key and value can be GCed if they are not stored anywhere else.
{
	let map = new WeakMap()

	var priv = function(key) {
		let p = map.get(key)
		if(!p){
			p = {}
			map.set(key,p)
		}
		return p
		
	}

	var _ = function(key) {
		return map.get(key)
	}
}