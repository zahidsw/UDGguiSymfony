
import {arrayToCSV, CSVtoArray} from "./CSVToArray.js"

/**
 * @name Serializers
 *
 * @type       {Object}
 */
const Serializers = {

	boolean : ()=>({
		read : b => b && b !== "false" , 
		write : b => !!b
	}),

	number : ()=>({
		read : n=> +n,
		write : b => +b
	}),

	date : buffered.bind(null,
		str => {
			let dstr = new Date(str)
			if(!+dstr){
				return new Date(+str)
			}
			return dstr
		},
		obj => new Date(obj)
		),

	json : JSONSerialize,

	string : ()=>({
		read : s => s || "",
		write : s => s || ""
	}),

	template : ()=> {
		let oldString,oldValue
		return {
			read : function read(str){
				if(str === oldString)
					return oldValue
				
				
				oldValue =  parseTemplateString(str)
				return oldValue

			},
			write : function write(str) {
				if(typeof str !== "string") {
					throw new Error("template attribute are asymmetrical and can only be set to a string")
				}

				if(str === oldString)
					return oldValue
				
				
				oldValue =  parseTemplateString(str)
				return oldValue
			},
			buffered  :true
		}
	},
	array : (typeBuilder) => bufferedArray( stringToArray,arrayToCSV,typeBuilder),
	array_csv : (typeBuilder) => bufferedArray( CSVtoArray,arrayToCSV,typeBuilder),
	array_lsv : (typeBuilder) => bufferedArray( LSVtoArray,arrayToLSV,typeBuilder),

	map : function(){return JSONSerialize.call(this,"{","}")},

	domelement : ()=> {
		let element
		let oldSelector
		return {
			read : str => {
				// Will query element each time on browser that do not provide isConnected
				if(!str)
					return null
				if(!(element && str === oldSelector && element.isConnected ))
					element = document.querySelector(str)
				oldSelector = str
				return element
			},
			write : elem => {
				if(!elem)
					return ""

				var selector = typeof elem === "string" ? elem : "#"+elem.id
				if(!selector)
					throw new Error("Cannot link "+elem+" to "+this.tagName+ " the provided element have no defined id.")
				oldSelector = selector
				return selector
			},
			buffered  :true
		}
	},
	"" : ()=>Serializers.string()
}

function buffered (read,write) {
	let value, oldString
	return {
			read : v => {
				if(v === oldString)
					return value
				oldString = v
				return value = read(v)
			},
			write : obj => {
				
				oldString = write(obj)
				value = obj
				
				return oldString || "" // Buffer the actual value but return empty string for any falsy serialized value.
			},
			buffered : true
		}
}

function bufferedArray(toArr,toString,innerTypeBuilder) {
	let type = innerTypeBuilder()
	let doBuffer = type.buffered
	let doRead = !!type.read
	let doWrite = !!type.write

	if(doBuffer)
		type = []

	let stringify = (arr)=>toString(arr)
	if(doWrite) {

		let assemble = stringify
		if(!doBuffer){
			stringify = (arr) => assemble(arr.map(e => type.write(e)))
		}else {
			stringify = (arr) => {
				if(arr.length !== type.length){
					type = adjustArray(type,arr.length,innerTypeBuilder)
				}

				return assemble(arr.map((e,i) => type[i].write(e)))
			}
		}
	}

	let parse = (str)=>toArr(str)
	if(doRead){
		let split = parse
		if(!doBuffer){
			parse = (str) => split(str).map(e=>type.read(e))
		}else {
			parse = (str) => {
				let arr = split(str)
				if(arr.length !== type.length){
					type = adjustArray(type,arr.length,innerTypeBuilder)
				}

				return arr.map((e,i) => type[i].read(e))
			}
		}
	}

	return buffered(parse,stringify)
}

function JSONSerialize (prefix,postfix) {

	if(!(prefix || postfix))
		return buffered(JSON.parse,JSON.stringify)

	prefix = prefix || ""
	postfix = postfix || ""

	return buffered(
			v => {
				if(!v)
					return {}
				return JSON.parse(prefix+v+postfix)
			},
			e => {
				
				if(!e)
					return ""

				let str = JSON.stringify(e)
				return str.slice(prefix.length,str.length - postfix.length)
			}
		)
}

function parseType(type) {
	
	// genereicArg Target a substring starting with the first occurrence of < and ending with a > being the last non-whitespace character of the string. 
	let regex = /^\s*([^<\s]+)\s*(?:<\s*([^\s]*)\s*>)?\s*$/g

	let match = regex.exec(type)

	if(!match)
		throw new Error("could not parse type "+type)

	let baseType = match[1]
	let genericArg = match[2]


	return {baseType,genericArg}

}

/**
 * Creates a new parser. May buffer the value to avoid desalinizing more than necessary. Better use on parser per attributes.
 *
 * @param      {string}  type    The type
 * 
 * @return     {Serializer~Parser.<Type>} a parser for the given type.
 * 
 */
function createBufferedParser(type,owner,name){
	if(!type)
		return null
	if(typeof type === "function")
		return type
	if(typeof type === "string"){
		let {baseType,genericArg} = parseType(type)
		let f = Serializers[baseType]
		
		if(!f)
			return 

		if(genericArg){
			try{
				let typeBuilder = createBufferedParser.bind(null,genericArg,owner,name)
				f = f.bind(null, typeBuilder)

			}catch(e){
				throw new Error("Could not parse "+type+" : \n"+(e.message || e))
			}
		}
		if(f.length > 1){
			throw new Error("Missing generic "+f.length+" arguments for type "+type)
		}

		return f.call(owner,name)

	}

	return ()=>({read:type.read, write : type.wite})

}

function stringToArray(str) {
	if(!str)
		return []
	if(str.includes("\n"))
		return LSVtoArray(str)
	return CSVtoArray(str)
}

function arrayToLSV(arr,indent){
	
	if(!arr || !arr.length)
		return ""

	indent = indent || ""
	return arr.join("\n"+indent)
}

function LSVtoArray(lsvString){
	if(!lsvString)
		return []

	return lsvString.trim().split(/\n\r?\s*/)
}

function parseTemplateString(str){
	let args = new Set()
	let argExp = /\${\s*([^}]+)}/g
	let match
	str = str.replace(/`/g,"")
	
	while(match = argExp.exec(str)){
		args.add(match[1])
	}

	let spread = `let { ${Array.from(args).join(",")} } = arg`
	let retur = `return \`${str}\``
	
	return new Function('arg',`${spread}\n${retur}`)
}

function adjustArray(array,expectedLength,fillFunc){
	let result = array.slice(0,expectedLength)

	if(isNaN(expectedLength))
		throw  new Error("Array cannot be adjusted to a length of "+expectedLength)

	while(result.length < expectedLength){
		result.push(fillFunc())
	}

	return result
}
/**
 * @typedef Serializer~Parser.<ParsedType> 
 * @prop {function(string):ParsedType} read deserialize an attribute.
 * @prop {function(ParsedType):string} write serialize an attribute.
 */


 /**
  * 
  */
export default createBufferedParser